using System.Collections.Generic;
using UnityEngine;

namespace SimplePool
{
	public class SimplePool<T> : IPool<T> where T : Object, IPoolable
	{
		private readonly List<T> _inUse = new List<T>();
		private readonly Queue<T> _available = new Queue<T>();
		private readonly T _prefab = null;

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public bool AutoAddInstances { get; set; }
		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public int AvailableInstancesCount { get { return _available == null ? 0 : _available.Count; } }
		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public int Count { get { return AvailableInstancesCount + InUseCount; } }
		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public int InUseCount { get { return _inUse == null ? 0 : _inUse.Count; } }

		public SimplePool(bool autoAddInstances, T prefab)
		{
			AutoAddInstances = autoAddInstances;
			_prefab = prefab;
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public void GenerateAvailableInstances(int amount, Transform originalParent)
		{
			for (int i = amount; i > 0; i--)
			{
				_available.Enqueue(CreateInstance(originalParent));
			}
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public void Clear()
		{
			while (_available.Count > 0)
			{
				DismissInstance(_available.Dequeue());
			}
			_available.Clear();
			for (int i = 0; i < _inUse.Count; i++)
			{
				DismissInstance(_inUse[i]);
			}
			_inUse.Clear();
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public T GetInstance(Transform autogeneratedInstanceOriginalParent)
		{
			T toReturn = default;
			if (_available.Count > 0)
			{
				toReturn = _available.Dequeue();
			}
			else if (AutoAddInstances)
			{
				Debug.LogWarning($"The pool run dry of {typeof(T).Name} but a new instance has been automatically created to fulfil the \"GetInstance\" request.");
				toReturn = CreateInstance(autogeneratedInstanceOriginalParent);
			}
			if (toReturn == null)
			{
				Debug.LogWarning($"The pool run dry of {typeof(T).Name} instances.");
			}
			else
			{
				_inUse.Add(toReturn);
			}
			return toReturn;
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public void GetInUseInstances(List<T> inUseShallow)
		{
			if (inUseShallow == null)
			{
				Debug.LogError("Impossible to fill the list of in use instances because the passed reference is null !!");
				return;
			}
			// empty the given list if necessary.
			if (inUseShallow.Count != 0)
			{
				inUseShallow.Clear();
			}
			// shallow copy.
			for (int i = 0; i < _inUse.Count; i++)
			{
				inUseShallow.Add(_inUse[i]);
			}
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public PoolableStatus GetInstanceCurrentStatus(T instance)
		{
			if (_available.Contains(instance))
			{
				return PoolableStatus.Available;
			}
			if (_inUse.Contains(instance))
			{
				return PoolableStatus.InUse;
			}

			return PoolableStatus.InUse; //  shouldn't reach this part
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public void ReturnAllInUseInstances()
		{
			for (int i = _inUse.Count - 1; i >= 0; i--)
			{
				ReturnInstance(_inUse[i]);
			}
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public void ReturnInstance(IPoolable instance)
		{
			ReturnInstance((T)instance);
		}

		/// <summary>
		/// <inheritdoc/>
		/// </summary>
		public void ReturnInstance(T instance)
		{
			instance.ResetInstance();
			bool inList = _inUse.Remove(instance);
			if (inList)
			{
				_available.Enqueue(instance);
			}
			else
			{
				if (_available.Contains(instance))
				{
					Debug.LogWarning("The instance you are trying to return to the pool is already in the available list. Aborting return operation.");
					return;
				}
				Debug.LogWarning("Dismissing the rogue instance.");
				DismissInstance(instance);
			}
		}

		private T CreateInstance(Transform originalParent)
		{
			T instance = Object.Instantiate(_prefab, originalParent, false);
			instance.SetOriginalParent(originalParent);
			instance.ResetInstance();
			instance.SetPool(this);
			return instance;
		}

		private void DismissInstance(T instance)
		{
			Component component = instance as Component;
			if (component != null)
			{
				Object.Destroy(component.gameObject);
				return;
			}
			Object.Destroy(instance);
		}
	}
}
